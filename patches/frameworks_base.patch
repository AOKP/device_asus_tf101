diff --git a/api/current.txt b/api/current.txt
index bc97e81..c75b087 100644
--- a/api/current.txt
+++ b/api/current.txt
@@ -15244,6 +15244,11 @@ package android.os {
     field public static final int BATTERY_STATUS_FULL = 5; // 0x5
     field public static final int BATTERY_STATUS_NOT_CHARGING = 4; // 0x4
     field public static final int BATTERY_STATUS_UNKNOWN = 1; // 0x1
+    field public static final int DOCK_STATE_CHARGING = 2; // 0x2
+    field public static final int DOCK_STATE_DISCHARGING = 4; // 0x4
+    field public static final int DOCK_STATE_DOCKED = 3; // 0x3
+    field public static final int DOCK_STATE_UNDOCKED = 1; // 0x1
+    field public static final int DOCK_STATE_UNKNOWN = 0; // 0x0
     field public static final java.lang.String EXTRA_HEALTH = "health";
     field public static final java.lang.String EXTRA_ICON_SMALL = "icon-small";
     field public static final java.lang.String EXTRA_LEVEL = "level";
diff --git a/core/java/android/os/BatteryManager.java b/core/java/android/os/BatteryManager.java
index c62715b..787426e 100644
--- a/core/java/android/os/BatteryManager.java
+++ b/core/java/android/os/BatteryManager.java
@@ -26,6 +26,12 @@ public class BatteryManager {
      * integer containing the current status constant.
      */
     public static final String EXTRA_STATUS = "status";
+
+    /**
+     * Integer containing the current status constant for the dock battery.
+     * @hide
+     */
+    public static final String EXTRA_DOCK_STATUS = "dock_status";
     
     /**
      * Extra for {@link android.content.Intent#ACTION_BATTERY_CHANGED}:
@@ -45,6 +51,18 @@ public class BatteryManager {
      * {@link #EXTRA_SCALE}.
      */
     public static final String EXTRA_LEVEL = "level";
+
+    /**
+     * Integer field containing the current dock battery level.
+     * @hide
+     */
+    public static final String EXTRA_DOCK_LEVEL = "dock_level";
+
+    /**
+     * Boolean field containing the current dock battery AC status.
+     * @hide
+     */
+    public static final String EXTRA_DOCK_AC_ONLINE = "dock_ac_online";
     
     /**
      * Extra for {@link android.content.Intent#ACTION_BATTERY_CHANGED}:
@@ -109,6 +127,13 @@ public class BatteryManager {
     public static final int BATTERY_HEALTH_UNSPECIFIED_FAILURE = 6;
     public static final int BATTERY_HEALTH_COLD = 7;
 
+    // values for "health" field in the ACTION_BATTERY_CHANGED Intent
+    public static final int DOCK_STATE_UNKNOWN = 0;
+    public static final int DOCK_STATE_UNDOCKED = 1;
+    public static final int DOCK_STATE_CHARGING = 2;
+    public static final int DOCK_STATE_DOCKED = 3;
+    public static final int DOCK_STATE_DISCHARGING = 4;
+
     // values of the "plugged" field in the ACTION_BATTERY_CHANGED intent.
     // These must be powers of 2.
     /** Power source is an AC charger. */
diff --git a/core/java/android/view/KeyEvent.java b/core/java/android/view/KeyEvent.java
index c2a3e58..9c4763f 100755
--- a/core/java/android/view/KeyEvent.java
+++ b/core/java/android/view/KeyEvent.java
@@ -623,8 +623,18 @@ public class KeyEvent extends InputEvent implements Parcelable {
     /** Key code constant: Assist key.
      * Launches the global assist activity.  Not delivered to applications. */
     public static final int KEYCODE_ASSIST          = 219;
-
-    private static final int LAST_KEYCODE           = KEYCODE_ASSIST;
+    public static final int KEYCODE_WIRELESS        = 220;
+    public static final int KEYCODE_BLUETOOTH       = 221;
+    public static final int KEYCODE_TOUCHPAD        = 222;
+    public static final int KEYCODE_BRIGHTNESS_UP   = 223;
+    public static final int KEYCODE_BRIGHTNESS_DOWN = 224;
+    public static final int KEYCODE_BRIGHTNESS_AUTO = 225;
+    public static final int KEYCODE_CAPTURE         = 226;
+    public static final int KEYCODE_EUROPE_1        = 227;
+    public static final int KEYCODE_EUROPE_2        = 228;
+    public static final int KEYCODE_SLEEP           = 229;
+
+    private static final int LAST_KEYCODE           = KEYCODE_SLEEP;
 
     // NOTE: If you add a new keycode here you must also add it to:
     //  isSystem()
@@ -866,6 +876,16 @@ public class KeyEvent extends InputEvent implements Parcelable {
         names.append(KEYCODE_RO, "KEYCODE_RO");
         names.append(KEYCODE_KANA, "KEYCODE_KANA");
         names.append(KEYCODE_ASSIST, "KEYCODE_ASSIST");
+        names.append(KEYCODE_WIRELESS, "KEYCODE_WIRELESS");
+        names.append(KEYCODE_BLUETOOTH, "KEYCODE_BLUETOOTH");
+        names.append(KEYCODE_TOUCHPAD, "KEYCODE_TOUCHPAD");
+        names.append(KEYCODE_BRIGHTNESS_UP, "KEYCODE_BRIGHTNESS_UP");
+        names.append(KEYCODE_BRIGHTNESS_DOWN, "KEYCODE_BRIGHTNESS_DOWN");
+        names.append(KEYCODE_BRIGHTNESS_AUTO, "KEYCODE_BRIGHTNESS_AUTO");
+        names.append(KEYCODE_CAPTURE, "KEYCODE_CAPTURE");
+        names.append(KEYCODE_EUROPE_1, "KEYCODE_EUROPE_1");
+        names.append(KEYCODE_EUROPE_2, "KEYCODE_EUROPE_2");
+        names.append(KEYCODE_SLEEP, "KEYCODE_SLEEP");
     };
 
     // Symbolic names of all metakeys in bit order from least significant to most significant.
diff --git a/core/java/android/view/WindowManagerPolicy.java b/core/java/android/view/WindowManagerPolicy.java
index 09948b8..365f97f 100644
--- a/core/java/android/view/WindowManagerPolicy.java
+++ b/core/java/android/view/WindowManagerPolicy.java
@@ -392,6 +392,7 @@ public interface WindowManagerPolicy {
         public void switchKeyboardLayout(int deviceId, int direction);
 
         public void shutdown();
+        public void reboot(String reason);
         public void rebootSafeMode();
     }
 
diff --git a/core/java/org/teameos/jellybean/settings/EOSConstants.java b/core/java/org/teameos/jellybean/settings/EOSConstants.java
new file mode 100644
index 0000000..efdd759
--- /dev/null
+++ b/core/java/org/teameos/jellybean/settings/EOSConstants.java
@@ -0,0 +1,303 @@
+
+package org.teameos.jellybean.settings;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+public final class EOSConstants {
+    /* EOS SETTINGS STRINGS */
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_BATTERY_ICON_VISIBLE = "eos_systemui_battery_icon_visible";
+
+    /**
+     * @hide
+     */
+    public static final int SYSTEMUI_BATTERY_ICON_VISIBLE_DEF = 1;
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_BATTERY_TEXT_VISIBLE = "eos_systemui_battery_text_visible";
+
+    /**
+     * @hide
+     */
+    public static final int SYSTEMUI_BATTERY_TEXT_VISIBLE_DEF = 1;
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_BATTERY_PERCENT_VISIBLE = "eos_systemui_battery_percent_visible";
+
+    /**
+     * @hide
+     */
+    public static final int SYSTEMUI_BATTERY_PERCENT_VISIBLE_DEF = 1;
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_BATTERY_PERCENT_TAG = "eos_systemui_battery_percent_tag";
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_BATTERY_TEXT_COLOR = "eos_systemui_battery_text_color";
+
+    /**
+     * @hide
+     */
+    public static final int SYSTEMUI_BATTERY_TEXT_COLOR_DEF = -1;
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_CLOCK_VISIBLE = "eos_systemui_clock_visible";
+
+    /**
+     * @hide
+     */
+    public static final int SYSTEMUI_CLOCK_VISIBLE_DEF = 1;
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_CLOCK_COLOR = "eos_systemui_clock_color";
+
+    /**
+     * @hide
+     */
+    public static final int SYSTEMUI_CLOCK_COLOR_DEF = -1;
+
+    /**
+     * @hide
+     */    
+    public static final String SYSTEMUI_CLOCK_AMPM = "eos_systemui_clock_ampm";
+
+    /**
+     * @hide
+     */
+    public static final int SYSTEMUI_CLOCK_AMPM_DEF = 2;
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_ENABLED = "eos_systemui_settings_enabled";
+
+    /**
+     * @hide
+     */
+    public static final int SYSTEMUI_SETTINGS_ENABLED_DEF = 0;
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_ENABLED_CONTROLS = "eos_systemui_settings_enabled_controls";
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_PHONE_TOP = "eos_systemui_settings_phone_top";
+
+    /**
+     * @hide
+     */
+    public static final int SYSTEMUI_SETTINGS_PHONE_TOP_DEF = 0;
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_PHONE_BOTTOM = "eos_systemui_settings_phone_bottom";
+
+    /**
+     * @hide
+     */
+    public static final int SYSTEMUI_SETTINGS_PHONE_BOTTOM_DEF = 0;
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_AIRPLANE = "eos_systemui_settings_airplane";
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_AUTO_ROTATE = "eos_systemui_settings_autorotate";
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_BLUETOOTH = "eos_systemui_settings_bluetooth";
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_GPS = "eos_systemui_settings_gps";
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_NOTIFICATIONS = "eos_systemui_settings_notifications";
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_SILENT = "eos_systemui_settings_silent";
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_TORCH = "eos_systemui_settings_torch";
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_WIFI = "eos_systemui_settings_wifi";
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_MOBILEDATA = "eos_systemui_settings_mobiledata";
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_WIFITETHER = "eos_systemui_settings_wifitether";
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_USBTETHER = "eos_systemui_settings_usbtether";
+
+    /**
+     * @hide
+     */
+    public static final String[] SYSTEMUI_SETTINGS_DEFAULTS = {
+            SYSTEMUI_SETTINGS_WIFI,
+            SYSTEMUI_SETTINGS_BLUETOOTH,
+            SYSTEMUI_SETTINGS_GPS,
+            SYSTEMUI_SETTINGS_AUTO_ROTATE,
+            SYSTEMUI_SETTINGS_SILENT
+    };
+
+    /**
+     * @hide
+     */
+    public static final Map<String, Boolean> getEosSystemUISettingsMap() {
+        LinkedHashMap<String, Boolean> map = new LinkedHashMap<String, Boolean>();
+        map.put(SYSTEMUI_SETTINGS_AIRPLANE, false);
+        map.put(SYSTEMUI_SETTINGS_AUTO_ROTATE, true);
+        map.put(SYSTEMUI_SETTINGS_BLUETOOTH, true);
+        map.put(SYSTEMUI_SETTINGS_GPS, true);
+        map.put(SYSTEMUI_SETTINGS_NOTIFICATIONS, false);
+        map.put(SYSTEMUI_SETTINGS_SILENT, true);
+        map.put(SYSTEMUI_SETTINGS_TORCH, false);
+        map.put(SYSTEMUI_SETTINGS_WIFI, true);
+        map.put(SYSTEMUI_SETTINGS_MOBILEDATA, false);
+        map.put(SYSTEMUI_SETTINGS_WIFITETHER, false);
+        map.put(SYSTEMUI_SETTINGS_USBTETHER, false);
+
+        return map;
+    }
+
+    /***
+     * EOS Intent constants
+     */
+
+    /**
+     * Broadcast Action: Request to turn Eos Torch application off
+     * 
+     * @hide
+     */
+    public static final String ACTION_TORCH_OFF = "android.intent.action.TORCH_OFF";
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_STANDARD_WIFI = "eos_systemui_settings_standard_wifi";
+    /**
+     * @hide
+     */
+    public static final int SYSTEMUI_SETTINGS_STANDARD_WIFI_DEF = 1;
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_STANDARD_AIRPLANE = "eos_systemui_settings_standard_airplane";
+    /**
+     * @hide
+     */
+    public static final int SYSTEMUI_SETTINGS_STANDARD_AIRPLANE_DEF = 1;
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_STANDARD_ROTATION = "eos_systemui_settings_standard_rotation";
+    /**
+     * @hide
+     */
+    public static final int SYSTEMUI_SETTINGS_STANDARD_ROTATION_DEF = 1;
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_STANDARD_VOLUME = "eos_systemui_settings_standard_volume";
+    /**
+     * @hide
+     */
+    public static final int SYSTEMUI_SETTINGS_STANDARD_VOLUME_DEF = 0;
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_STANDARD_BRIGHTNESS = "eos_systemui_settings_standard_brightness";
+    /**
+     * @hide
+     */
+    public static final int SYSTEMUI_SETTINGS_STANDARD_BRIGHTNESS_DEF = 1;
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_STANDARD_NOTIFICATIONS = "eos_systemui_settings_standard_notifications";
+    /**
+     * @hide
+     */
+    public static final int SYSTEMUI_SETTINGS_STANDARD_NOTIFICATIONS_DEF = 1;
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_STANDARD_SETTINGS = "eos_systemui_settings_standard_settings";
+    /**
+     * @hide
+     */
+    public static final int SYSTEMUI_SETTINGS_STANDARD_SETTINGS_DEF = 1;
+    /**
+     * The touchpad gesture mode. (0 = spots, 1 = pointer)
+     * @hide
+     */
+    public static final String DEVICE_SETTINGS_TOUCHPAD_MODE = "eos_device_settings_touchpad_mode";
+    /**
+     * Whether or not the touchpad is enabled. (0 = false, 1 = true)
+     * @hide
+     */
+    public static final String DEVICE_SETTINGS_TOUCHPAD_STATUS = "eos_device_settings_touchpad_status";
+    /**
+     * Value for {@link #EOS_TOUCHPAD_STATUS} to use
+     * the touchpad located on the hardware keyboard dock.
+     * @hide
+     */
+    public static final int DEVICE_SETTINGS_TOUCHPAD_DISABLED = 0;
+    /**
+     * Value for {@link #EOS_TOUCHPAD_STATUS} to use
+     * the touchpad located on the hardware keyboard dock.
+     * @hide
+     */
+    public static final int DEVICE_SETTINGS_TOUCHPAD_ENABLED = 1;
+    /**
+     * On the grouper, we use this to switch between the hybrid UI and the tablet UI
+     * @hide
+     */
+    public static final String SYSTEMUI_USE_TABLET_UI = "eos_systemui_tablet_ui";
+    /**
+     * @hide
+     */
+    public static final int SYSTEMUI_USE_TABLET_UI_DEF = 0;
+}
diff --git a/core/jni/Android.mk b/core/jni/Android.mk
index c24f6c6..ba8dfbc 100644
--- a/core/jni/Android.mk
+++ b/core/jni/Android.mk
@@ -23,6 +23,10 @@ ifeq ($(USE_OPENGL_RENDERER),true)
 	LOCAL_CFLAGS += -DUSE_OPENGL_RENDERER
 endif
 
+ifeq ($(TARGET_USES_ICS_CAMERA_BLOB),true)
+	LOCAL_CFLAGS += -DICS_CAMERA_BLOB
+endif
+
 LOCAL_CFLAGS += -DGL_GLEXT_PROTOTYPES -DEGL_EGLEXT_PROTOTYPES
 
 LOCAL_SRC_FILES:= \
diff --git a/core/jni/android_hardware_Camera.cpp b/core/jni/android_hardware_Camera.cpp
index 6cd8955..9dab1d2 100644
--- a/core/jni/android_hardware_Camera.cpp
+++ b/core/jni/android_hardware_Camera.cpp
@@ -813,12 +813,16 @@ static void android_hardware_Camera_stopFaceDetection(JNIEnv *env, jobject thiz)
 static void android_hardware_Camera_enableFocusMoveCallback(JNIEnv *env, jobject thiz, jint enable)
 {
     ALOGV("enableFocusMoveCallback");
+#ifdef ICS_CAMERA_BLOB
+    return;
+#else
     sp<Camera> camera = get_native_camera(env, thiz, NULL);
     if (camera == 0) return;
 
     if (camera->sendCommand(CAMERA_CMD_ENABLE_FOCUS_MOVE_MSG, enable, 0) != NO_ERROR) {
         jniThrowRuntimeException(env, "enable focus move callback failed");
     }
+#endif
 }
 
 //-------------------------------------------------
diff --git a/core/res/res/drawable-hdpi/ic_lock_reboot.png b/core/res/res/drawable-hdpi/ic_lock_reboot.png
new file mode 100644
index 0000000..4beeb87
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lock_reboot.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lock_reboot.png b/core/res/res/drawable-mdpi/ic_lock_reboot.png
new file mode 100644
index 0000000..2b125b9
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lock_reboot.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lock_reboot.png b/core/res/res/drawable-xhdpi/ic_lock_reboot.png
new file mode 100644
index 0000000..f27e5e4
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lock_reboot.png differ
diff --git a/core/res/res/values/arrays.xml b/core/res/res/values/arrays.xml
index b425ad7..a5328c5 100644
--- a/core/res/res/values/arrays.xml
+++ b/core/res/res/values/arrays.xml
@@ -407,4 +407,15 @@
         <item>@null</item>
     </array>
 
+    <!-- reboot options -->
+    <string-array name="reboot_options">
+		<item>@string/reboot</item>
+		<item>@string/reboot_recovery</item>
+    </string-array>
+
+    <!-- reboot values -->
+    <string-array name="reboot_values">
+		<item></item>
+		<item>recovery</item>
+    </string-array>
 </resources>
diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index ccc85a3..f12ce4d 100755
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -865,4 +865,10 @@
 
     <!-- Set to true to add links to Cell Broadcast app from Settings and MMS app. -->
     <bool name="config_cellBroadcastAppLinks">false</bool>
+
+     <!-- Dock battery compatibility disabled by default -->
+    <bool name="config_hasDockBattery">false</bool>
+
+    <!-- Touchpad compatibility disabled by default -->
+    <bool name="config_hasTouchpad">false</bool>
 </resources>
diff --git a/core/res/res/values/public.xml b/core/res/res/values/public.xml
index 0bae0cb..af81686 100644
--- a/core/res/res/values/public.xml
+++ b/core/res/res/values/public.xml
@@ -265,6 +265,8 @@
   <java-symbol type="bool" name="config_sendAudioBecomingNoisy" />
   <java-symbol type="bool" name="config_enableScreenshotChord" />
   <java-symbol type="bool" name="config_bluetooth_default_profiles" />
+  <java-symbol type="bool" name="config_hasDockBattery" />
+  <java-symbol type="bool" name="config_hasTouchpad" />
 
   <java-symbol type="integer" name="config_cursorWindowSize" />
   <java-symbol type="integer" name="config_longPressOnPowerBehavior" />
@@ -1202,6 +1204,8 @@
   <java-symbol type="array" name="lockscreen_targets_when_silent" />
   <java-symbol type="array" name="lockscreen_targets_when_soundon" />
   <java-symbol type="array" name="lockscreen_targets_with_camera" />
+  <java-symbol type="array" name="reboot_options" />
+  <java-symbol type="array" name="reboot_values" />
   <java-symbol type="attr" name="actionModePopupWindowStyle" />
   <java-symbol type="attr" name="dialogCustomTitleDecorLayout" />
   <java-symbol type="attr" name="dialogTitleDecorLayout" />
@@ -1227,6 +1231,7 @@
   <java-symbol type="drawable" name="ic_jog_dial_vibrate_on" />
   <java-symbol type="drawable" name="ic_lock_airplane_mode" />
   <java-symbol type="drawable" name="ic_lock_airplane_mode_off" />
+  <java-symbol type="drawable" name="ic_lock_reboot" />
   <java-symbol type="drawable" name="ic_menu_cc" />
   <java-symbol type="drawable" name="jog_tab_bar_left_unlock" />
   <java-symbol type="drawable" name="jog_tab_bar_right_sound_off" />
@@ -1366,6 +1371,7 @@
   <java-symbol type="string" name="lockscreen_too_many_failed_pin_attempts_dialog_message" />
   <java-symbol type="string" name="lockscreen_unlock_label" />
   <java-symbol type="string" name="status_bar_device_locked" />
+  <java-symbol type="string" name="reboot" />
   <java-symbol type="style" name="Animation.LockScreen" />
   <java-symbol type="style" name="Theme.Dialog.RecentApplications" />
   <java-symbol type="style" name="Theme.ExpandedMenu" />
@@ -1543,6 +1549,7 @@
   <java-symbol type="string" name="vpn_title" />
   <java-symbol type="string" name="vpn_title_long" />
   <java-symbol type="string" name="wallpaper_binding_label" />
+  <java-symbol type="string" name="reboot_progress" />
   <java-symbol type="style" name="Theme.Dialog.AppError" />
   <java-symbol type="style" name="Theme.Toast" />
   <java-symbol type="xml" name="storage_list" />
@@ -3651,5 +3658,4 @@
   <public type="style" name="Widget.Holo.Light.MediaRouteButton" id="0x010301d6" />
   <public type="style" name="Widget.DeviceDefault.MediaRouteButton" id="0x010301d7" />
   <public type="style" name="Widget.DeviceDefault.Light.MediaRouteButton" id="0x010301d8" />
-
 </resources>
diff --git a/core/res/res/values/strings.xml b/core/res/res/values/strings.xml
index 325b6fe..228c845 100755
--- a/core/res/res/values/strings.xml
+++ b/core/res/res/values/strings.xml
@@ -3576,4 +3576,19 @@
 
     <!-- "Done" button for MediaRouter chooser dialog when grouping routes. [CHAR LIMIT=NONE] -->
     <string name="media_route_chooser_grouping_done">Done</string>
+
+    <!-- Reboot -->
+    <string name="reboot">Reboot</string>
+
+    <!-- Reboot recovery option -->
+    <string name="reboot_recovery">Recovery</string>
+
+    <!-- Reboot recovery option -->
+    <string name="reboot_download">Download</string>
+
+    <!-- Reboot recovery option -->
+    <string name="reboot_bootloader">Bootloader</string>
+
+    <!-- Rebooting message -->
+    <string name="reboot_progress">Your device is rebooting</string>
 </resources>
diff --git a/include/androidfw/KeycodeLabels.h b/include/androidfw/KeycodeLabels.h
index 538949d..dbfeab1 100755
--- a/include/androidfw/KeycodeLabels.h
+++ b/include/androidfw/KeycodeLabels.h
@@ -244,6 +244,16 @@ static const KeycodeLabel KEYCODES[] = {
     { "RO", 217 },
     { "KANA", 218 },
     { "ASSIST", 219 },
+    { "WIRELESS", 220 },
+    { "BLUETOOTH", 221 },
+    { "TOUCHPAD", 222 },
+    { "BRIGHTNESS_UP", 223 },
+    { "BRIGHTNESS_DOWN", 224 },
+    { "BRIGHTNESS_AUTO", 225 },
+    { "CAPTURE", 226 },
+    { "EUROPE_1", 227 },
+    { "EUROPE_2", 228 },
+    { "SLEEP", 229 },
 
     // NOTE: If you add a new keycode here you must also add it to several other files.
     //       Refer to frameworks/base/core/java/android/view/KeyEvent.java for the full list.
diff --git a/policy/src/com/android/internal/policy/impl/GlobalActions.java b/policy/src/com/android/internal/policy/impl/GlobalActions.java
index fc187ce..144d358 100644
--- a/policy/src/com/android/internal/policy/impl/GlobalActions.java
+++ b/policy/src/com/android/internal/policy/impl/GlobalActions.java
@@ -53,6 +53,7 @@ import android.widget.AdapterView;
 import android.widget.BaseAdapter;
 import android.widget.ImageView;
 import android.widget.TextView;
+import android.widget.Toast;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -89,6 +90,8 @@ class GlobalActions implements DialogInterface.OnDismissListener, DialogInterfac
 
     private IWindowManager mIWindowManager;
 
+    private static int rebootIndex = 0;
+
     /**
      * @param context everything needs a context :(
      */
@@ -224,6 +227,28 @@ class GlobalActions implements DialogInterface.OnDismissListener, DialogInterfac
                 }
             });
 
+        // next: reboot
+        mItems.add(
+                new SinglePressAction(
+                        com.android.internal.R.drawable.ic_lock_reboot,
+                        com.android.internal.R.string.reboot) {
+
+                    @Override
+                    public boolean showDuringKeyguard() {
+                        return true;
+                    }
+
+                    @Override
+                    public boolean showBeforeProvisioning() {
+                        return true;
+                    }
+
+                    @Override
+                    public void onPress() {
+                        createRebootDialog().show();
+                    }
+                });
+
         // next: airplane mode
         mItems.add(mAirplaneModeOn);
 
@@ -816,4 +841,38 @@ class GlobalActions implements DialogInterface.OnDismissListener, DialogInterfac
         }
         return mIWindowManager;
     }
+
+    private AlertDialog createRebootDialog() {
+        final String[] rebootOptions = mContext.getResources().getStringArray(R.array.reboot_options);
+        final String[] rebootReasons = mContext.getResources().getStringArray(R.array.reboot_values);
+
+        AlertDialog d = new AlertDialog.Builder(mContext)
+                .setSingleChoiceItems(rebootOptions, 0,
+                        new DialogInterface.OnClickListener() {
+                            @Override
+                            public void onClick(DialogInterface dialog, int which) {
+                                rebootIndex = which;
+                            }
+                        })
+                .setNegativeButton(android.R.string.cancel,
+                        new DialogInterface.OnClickListener() {
+
+                            @Override
+                            public void onClick(DialogInterface dialog, int which) {
+                                dialog.dismiss();
+                            }
+                        })
+                .setPositiveButton(R.string.reboot, new DialogInterface.OnClickListener() {
+
+                    @Override
+                    public void onClick(DialogInterface dialog, int which) {
+                        mWindowManagerFuncs.reboot(rebootReasons[rebootIndex]);
+                    }
+                }).create();
+
+        d.getListView().setItemsCanFocus(true);
+        d.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG);
+
+        return d;
+    }
 }
diff --git a/policy/src/com/android/internal/policy/impl/KeyguardViewBase.java b/policy/src/com/android/internal/policy/impl/KeyguardViewBase.java
index 29a5573..3c8b211 100644
--- a/policy/src/com/android/internal/policy/impl/KeyguardViewBase.java
+++ b/policy/src/com/android/internal/policy/impl/KeyguardViewBase.java
@@ -215,11 +215,13 @@ public abstract class KeyguardViewBase extends FrameLayout {
                         }
                         // Volume buttons should only function for music (local or remote).
                         // TODO: Actually handle MUTE.
-                        mAudioManager.adjustLocalOrRemoteStreamVolume(
-                                AudioManager.STREAM_MUSIC,
-                                keyCode == KeyEvent.KEYCODE_VOLUME_UP
-                                        ? AudioManager.ADJUST_RAISE
-                                        : AudioManager.ADJUST_LOWER);
+                        if (keyCode != KeyEvent.KEYCODE_VOLUME_MUTE) {
+                            mAudioManager.adjustLocalOrRemoteStreamVolume(
+                                    AudioManager.STREAM_MUSIC,
+                                    keyCode == KeyEvent.KEYCODE_VOLUME_UP
+                                            ? AudioManager.ADJUST_RAISE
+                                            : AudioManager.ADJUST_LOWER);
+                        }
                         // Don't execute default volume behavior
                         return true;
                     } else {
diff --git a/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java b/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java
index 25da642..ad6007a 100755
--- a/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java
+++ b/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java
@@ -21,6 +21,7 @@ import android.app.IUiModeManager;
 import android.app.ProgressDialog;
 import android.app.SearchManager;
 import android.app.UiModeManager;
+import android.bluetooth.BluetoothAdapter;
 import android.content.ActivityNotFoundException;
 import android.content.BroadcastReceiver;
 import android.content.ComponentName;
@@ -40,10 +41,12 @@ import android.graphics.PixelFormat;
 import android.graphics.Rect;
 import android.media.AudioManager;
 import android.media.IAudioService;
+import android.net.wifi.WifiManager;
 import android.os.BatteryManager;
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.IBinder;
+import android.os.IPowerManager;
 import android.os.IRemoteCallback;
 import android.os.LocalPowerManager;
 import android.os.Looper;
@@ -57,6 +60,7 @@ import android.os.SystemProperties;
 import android.os.UEventObserver;
 import android.os.Vibrator;
 import android.provider.Settings;
+import android.provider.Settings.SettingNotFoundException;
 
 import com.android.internal.R;
 import com.android.internal.policy.PolicyManager;
@@ -140,6 +144,7 @@ import android.view.KeyCharacterMap.FallbackAction;
 import android.view.accessibility.AccessibilityEvent;
 import android.view.animation.Animation;
 import android.view.animation.AnimationUtils;
+import android.widget.Toast;
 
 import java.io.File;
 import java.io.FileReader;
@@ -3297,6 +3302,11 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                         mVolumeUpKeyTriggered = false;
                         cancelPendingScreenshotChordAction();
                     }
+                } else if (keyCode == KeyEvent.KEYCODE_VOLUME_MUTE) {
+                    if (down) {
+                        muteVolume(keyguardActive);
+                    }
+                    break;
                 }
                 if (down) {
                     ITelephony telephonyService = getTelephonyService();
@@ -3373,6 +3383,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 break;
             }
 
+            case KeyEvent.KEYCODE_SLEEP:
             case KeyEvent.KEYCODE_POWER: {
                 result &= ~ACTION_PASS_TO_USER;
                 if (down) {
@@ -3476,10 +3487,198 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 }
                 break;
             }
+
+            case KeyEvent.KEYCODE_WIRELESS:
+            case KeyEvent.KEYCODE_BLUETOOTH:
+            case KeyEvent.KEYCODE_TOUCHPAD:
+            case KeyEvent.KEYCODE_CAPTURE:
+            case KeyEvent.KEYCODE_SETTINGS:{
+                if (down) {
+                    mHandler.post(new Runnable() {
+                        public void run() {
+                            if (keyCode == KeyEvent.KEYCODE_WIRELESS) {
+                                wifiToggle();
+                            } else if (keyCode == KeyEvent.KEYCODE_BLUETOOTH) {
+                                bluetoothToggle();
+                            } else if (keyCode == KeyEvent.KEYCODE_TOUCHPAD) {
+                                touchpadToggle();
+                            } else if (keyCode == KeyEvent.KEYCODE_CAPTURE) {
+                                takeScreenshot();
+                            } else if (keyCode == KeyEvent.KEYCODE_SETTINGS) {
+                                launchSettings();
+                            }
+                        }
+                    });
+                }
+                break;
+            }
+
+            case KeyEvent.KEYCODE_BRIGHTNESS_DOWN:
+            case KeyEvent.KEYCODE_BRIGHTNESS_UP:
+            case KeyEvent.KEYCODE_BRIGHTNESS_AUTO: {
+                if (down) {
+                    mHandler.post(new Runnable() {
+                        public void run() {
+                            brightnessControl(keyCode);
+                        }
+                    });
+                }
+                break;
+            }
         }
         return result;
     }
 
+    private void muteVolume(boolean keyguardActive) {
+        AudioManager audioManager = (AudioManager) mContext
+                .getSystemService(Context.AUDIO_SERVICE);
+        int ringerMode = audioManager.getRingerMode();
+        if (ringerMode == AudioManager.RINGER_MODE_NORMAL) {
+            if (!keyguardActive) {
+                audioManager.adjustVolume(AudioManager.ADJUST_SAME, AudioManager.FLAG_SHOW_UI);
+            }
+            int vibrateMode = AudioManager.RINGER_MODE_VIBRATE;
+            // Check if vibrate in silent mode (default) should be overridden.
+            if (android.provider.Settings.System.getInt(
+                    mContext.getContentResolver(),
+                    Settings.System.VIBRATE_IN_SILENT, vibrateMode) == AudioManager.RINGER_MODE_VIBRATE) {
+                vibrateMode = AudioManager.RINGER_MODE_VIBRATE;
+                Vibrator vibrator = (Vibrator) mContext
+                        .getSystemService(Context.VIBRATOR_SERVICE);
+                vibrator.vibrate(300);
+            } else {
+                vibrateMode = AudioManager.RINGER_MODE_SILENT;
+            }
+            audioManager.setRingerMode(vibrateMode);
+        } else {
+            audioManager.setRingerMode(AudioManager.RINGER_MODE_NORMAL);
+            if (!keyguardActive) {
+                audioManager.adjustVolume(AudioManager.ADJUST_SAME, AudioManager.FLAG_SHOW_UI);
+            }
+        }
+    }
+
+    private void wifiToggle() {
+        WifiManager wifiManager = (WifiManager) mContext
+                .getSystemService("wifi");
+        boolean wifiState = wifiManager.isWifiEnabled();
+        if (wifiState) {
+            wifiManager.setWifiEnabled(false);
+            Toast.makeText(mContext, "Wifi Disabled", Toast.LENGTH_SHORT).show();
+        } else {
+            wifiManager.setWifiEnabled(true);
+            Toast.makeText(mContext, "Wifi Enabled", Toast.LENGTH_SHORT).show();
+        }
+    }
+
+    private void bluetoothToggle() {
+        BluetoothAdapter btAdapter = BluetoothAdapter.getDefaultAdapter();
+        boolean btState = btAdapter.isEnabled();
+        if (btState) {
+            btAdapter.disable();
+            Toast.makeText(mContext, "Bluetooth Disabled", Toast.LENGTH_SHORT).show();
+        } else {
+            btAdapter.enable();
+            Toast.makeText(mContext, "Bluetooth Enabled", Toast.LENGTH_SHORT).show();
+        }
+    }
+
+    private void brightnessControl(int keyCode) {
+        int level = 255;
+        int incrementBacklight = 15;
+        if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP) {
+            setBrightnessMode(Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL);
+         // Prevent the new brightness value from exceeding 255
+            if ((getBrightness() + (2 * incrementBacklight)) <= level) {
+                level = getBrightness() + incrementBacklight;
+            }
+            setBrightness(level);
+        } else if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_DOWN) {
+            setBrightnessMode(Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL);
+            level = 4;
+            // Prevent the new brightness value from falling below 4
+            if (getBrightness() - 2 * incrementBacklight >= level) {
+                level = getBrightness() - incrementBacklight;
+            }
+            setBrightness(level);
+        } else {
+            if (getBrightnessMode() == Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL) {
+                setBrightnessMode(Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC);
+            } else {
+                setBrightnessMode(Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL);
+                setBrightness(getBrightness());
+            }
+        }
+    }
+
+    private int getBrightness() {
+        try {
+            int level = android.provider.Settings.System.getInt(
+                    mContext.getContentResolver(),
+                    Settings.System.SCREEN_BRIGHTNESS);
+            return level;
+        } catch (SettingNotFoundException e) {
+            Log.e(TAG, "Couldn't get brightness setting. ", e);
+            return 255;
+        }
+    }
+
+    private int getBrightnessMode() {
+        try {
+            int mode = android.provider.Settings.System.getInt(
+                    mContext.getContentResolver(),
+                    Settings.System.SCREEN_BRIGHTNESS_MODE);
+            return mode;
+        } catch (SettingNotFoundException e) {
+            Log.e(TAG, "Couldn't get brightness mode. ", e);
+            return 0;
+        }
+
+    }
+    private void setBrightness(int level)
+    {
+        try {
+            android.provider.Settings.System.putInt(mContext.getContentResolver(),
+                    Settings.System.SCREEN_BRIGHTNESS, level);
+            IPowerManager ipowermanager =
+                    IPowerManager.Stub.asInterface(ServiceManager.getService("power"));
+            if(ipowermanager != null) {
+                ipowermanager.setBacklightBrightness(level);
+            }
+        } catch (RemoteException e) {;
+        Log.e(TAG, "Couldn't set brightness level. ", e);
+        }
+        return;
+    }
+
+    private void setBrightnessMode(int mode)
+    {
+        if(getBrightnessMode() != mode)
+            android.provider.Settings.System.putInt(mContext.getContentResolver(),
+                    Settings.System.SCREEN_BRIGHTNESS_MODE, mode);
+    }
+
+    private void launchSettings() {
+        Intent intent = new Intent("android.settings.SETTINGS");
+        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+        mContext.startActivity(intent);
+    }
+
+    private void touchpadToggle() {
+        int touchpadStatus = EOSConstants.DEVICE_SETTINGS_TOUCHPAD_ENABLED;
+        // Check whether touchpad input is currently enabled (default).
+        if (android.provider.Settings.System.getInt(
+                mContext.getContentResolver(),
+                EOSConstants.DEVICE_SETTINGS_TOUCHPAD_STATUS, touchpadStatus) == EOSConstants.DEVICE_SETTINGS_TOUCHPAD_ENABLED) {
+            // ...and if so prepare to disable it.
+            touchpadStatus = EOSConstants.DEVICE_SETTINGS_TOUCHPAD_DISABLED;
+        }
+        android.provider.Settings.System.putInt(mContext.getContentResolver(),
+                EOSConstants.DEVICE_SETTINGS_TOUCHPAD_STATUS, touchpadStatus);
+        String status = (touchpadStatus == EOSConstants.DEVICE_SETTINGS_TOUCHPAD_ENABLED) ? "Enabled" : "Disabled";
+        Toast.makeText(mContext, "Touchpad " + status, Toast.LENGTH_SHORT).show();
+    }
+
     /** {@inheritDoc} */
     @Override
     public int interceptMotionBeforeQueueingWhenScreenOff(int policyFlags) {
diff --git a/services/input/Android.mk b/services/input/Android.mk
index 159800f..f588b8b 100644
--- a/services/input/Android.mk
+++ b/services/input/Android.mk
@@ -44,6 +44,11 @@ LOCAL_MODULE:= libinput
 
 LOCAL_MODULE_TAGS := optional
 
+ifeq ($(TARGET_USES_TF101_LID_HACK),true)
+    $(info WARNING: TF101 lid hack can cause various weird side effects on other devices! Use with caution)
+    LOCAL_CFLAGS += -DTF101_LID_HACK
+endif
+
 include $(BUILD_SHARED_LIBRARY)
 
 
diff --git a/services/input/InputReader.cpp b/services/input/InputReader.cpp
index cd6a2ec..75f03fb 100644
--- a/services/input/InputReader.cpp
+++ b/services/input/InputReader.cpp
@@ -19,7 +19,7 @@
 //#define LOG_NDEBUG 0
 
 // Log debug messages for each raw event received from the EventHub.
-#define DEBUG_RAW_EVENTS 0
+#define DEBUG_RAW_EVENTS 1
 
 // Log debug messages about touch screen filtering hacks.
 #define DEBUG_HACKS 0
@@ -1829,7 +1829,17 @@ uint32_t SwitchInputMapper::getSources() {
 void SwitchInputMapper::process(const RawEvent* rawEvent) {
     switch (rawEvent->type) {
     case EV_SW:
-        processSwitch(rawEvent->when, rawEvent->code, rawEvent->value);
+#ifdef TF101_LID_HACK
+        if ( (rawEvent->deviceId == 2) && (rawEvent->code == 0) ) {
+            uint32_t newValue = rawEvent->value == 0 ? 1 : 0;
+            ALOGD("Flipping TF101 lid event! New code = %d", newValue);
+            processSwitch(rawEvent->when, rawEvent->code, newValue);
+        } else {
+            processSwitch(rawEvent->when, rawEvent->code, rawEvent->value);
+        }
+#else
+            processSwitch(rawEvent->when, rawEvent->code, rawEvent->value);
+#endif
         break;
     }
 }
@@ -1840,7 +1850,16 @@ void SwitchInputMapper::processSwitch(nsecs_t when, int32_t switchCode, int32_t
 }
 
 int32_t SwitchInputMapper::getSwitchState(uint32_t sourceMask, int32_t switchCode) {
-    return getEventHub()->getSwitchState(getDeviceId(), switchCode);
+    int32_t oldCode = getEventHub()->getSwitchState(getDeviceId(), switchCode);
+#ifdef TF101_LID_HACK
+    if (switchCode == SW_LID) {
+        return oldCode == 0 ? 1 : 0;
+    } else {
+        return oldCode;
+    }
+#else
+    return oldCode;
+#endif
 }
 
 
@@ -2691,6 +2710,15 @@ void TouchInputMapper::configure(nsecs_t when,
 
     mConfig = *config;
 
+    bool disableTouchpad = false;
+
+    // Find out if the touchpad is disabled.
+    if (mParameters.deviceType == Parameters::DEVICE_TYPE_POINTER) {
+        if (mConfig.touchpadStatus == 0) {
+            disableTouchpad = true;
+        }
+    }
+
     if (!changes) { // first time only
         // Configure basic parameters.
         configureParameters();
@@ -2723,11 +2751,45 @@ void TouchInputMapper::configure(nsecs_t when,
         configureSurface(when, &resetNeeded);
     }
 
+    if (mParameters.deviceType == Parameters::DEVICE_TYPE_POINTER) {
+        if (!changes || (changes & InputReaderConfiguration::CHANGE_TOUCHPAD_MODE)) {
+            // Change touchpad gesture
+            if (mConfig.touchpadMode == 0) {
+                mParameters.gestureMode = Parameters::GESTURE_MODE_SPOTS;
+            } else if (mConfig.touchpadMode == 1) {
+                mParameters.gestureMode = Parameters::GESTURE_MODE_POINTER;
+            } else {
+                ALOGW("Invalid value for touchpadMode: '%d'", mConfig.touchpadMode);
+            }
+            // Configure device sources, surface dimensions, orientation and
+            // scaling factors.
+            configureSurface(when, &resetNeeded);
+        }
+
+        if (!changes || (changes & InputReaderConfiguration::CHANGE_TOUCHPAD_STATUS)) {
+            // Change touchpad status.
+            if (mConfig.touchpadStatus == 0) {
+                disableTouchpad = true;
+            } else if (mConfig.touchpadStatus == 1) {
+                disableTouchpad = false;
+                // Configure device sources, surface dimensions, orientation and
+                // scaling factors.  This also conveniently re-enables the touchpad.
+                configureSurface(when, &resetNeeded);
+            } else {
+                ALOGW("Invalid value for touchpadStatus: '%d'", mConfig.touchpadStatus);
+            }
+        }
+    }
+
     if (changes && resetNeeded) {
         // Send reset, unless this is the first time the device has been configured,
         // in which case the reader will call reset itself after all mappers are ready.
         getDevice()->notifyReset(when);
     }
+    // disable the touchpad if required
+    if (disableTouchpad) {
+        mDeviceMode = DEVICE_MODE_DISABLED;
+    }
 }
 
 void TouchInputMapper::configureParameters() {
diff --git a/services/input/InputReader.h b/services/input/InputReader.h
index 122a2ab..5a73e2d 100644
--- a/services/input/InputReader.h
+++ b/services/input/InputReader.h
@@ -75,6 +75,12 @@ struct InputReaderConfiguration {
         // The device name alias supplied by the may have changed for some devices.
         CHANGE_DEVICE_ALIAS = 1 << 5,
 
+        // The touchpad gesture mode has changed.
+        CHANGE_TOUCHPAD_MODE = 1 << 6,
+
+        // The touchpad status has changed.
+        CHANGE_TOUCHPAD_STATUS = 1 << 7,
+
         // All devices must be reopened.
         CHANGE_MUST_REOPEN = 1 << 31,
     };
@@ -162,6 +168,12 @@ struct InputReaderConfiguration {
     // True to show the location of touches on the touch screen as spots.
     bool showTouches;
 
+    // The touchpad gesture mode.
+    int32_t touchpadMode;
+
+    // Touchpad status.
+    int32_t touchpadStatus;
+
     InputReaderConfiguration() :
             virtualKeyQuietTime(0),
             pointerVelocityControlParameters(1.0f, 500.0f, 3000.0f, 3.0f),
@@ -178,7 +190,9 @@ struct InputReaderConfiguration {
             pointerGestureSwipeMaxWidthRatio(0.25f),
             pointerGestureMovementSpeedRatio(0.8f),
             pointerGestureZoomSpeedRatio(0.3f),
-            showTouches(false) { }
+            showTouches(false),
+            touchpadMode(0),
+            touchpadStatus(1) { }
 
     bool getDisplayInfo(int32_t displayId, bool external,
             int32_t* width, int32_t* height, int32_t* orientation) const;
diff --git a/services/java/com/android/server/BatteryService.java b/services/java/com/android/server/BatteryService.java
index ab9ae69..210f87a 100644
--- a/services/java/com/android/server/BatteryService.java
+++ b/services/java/com/android/server/BatteryService.java
@@ -125,6 +125,11 @@ class BatteryService extends Binder {
 
     private boolean mSentLowBatteryBroadcast = false;
 
+    private boolean mHasDockBattery;
+    private int mDockBatteryStatus;
+    private int mDockBatteryLevel;
+    private String mDockBatteryPresent;
+
     public BatteryService(Context context, LightsService lights) {
         mContext = context;
         mLed = new Led(context, lights);
@@ -137,6 +142,9 @@ class BatteryService extends Binder {
         mLowBatteryCloseWarningLevel = mContext.getResources().getInteger(
                 com.android.internal.R.integer.config_lowBatteryCloseWarningLevel);
 
+        mHasDockBattery = mContext.getResources().getBoolean(
+                com.android.internal.R.bool.config_hasDockBattery);
+
         mPowerSupplyObserver.startObserving("SUBSYSTEM=power_supply");
 
         // watch for invalid charger messages if the invalid_charger switch exists
@@ -390,6 +398,12 @@ class BatteryService extends Binder {
         intent.putExtra(BatteryManager.EXTRA_TECHNOLOGY, mBatteryTechnology);
         intent.putExtra(BatteryManager.EXTRA_INVALID_CHARGER, mInvalidCharger);
 
+        if (mHasDockBattery){
+            intent.putExtra(BatteryManager.EXTRA_DOCK_STATUS, mDockBatteryStatus);
+            intent.putExtra(BatteryManager.EXTRA_DOCK_LEVEL, mDockBatteryLevel);
+            intent.putExtra(BatteryManager.EXTRA_DOCK_AC_ONLINE, false);
+        }
+
         if (false) {
             Slog.d(TAG, "level:" + mBatteryLevel +
                     " scale:" + BATTERY_SCALE + " status:" + mBatteryStatus +
diff --git a/services/java/com/android/server/input/InputManagerService.java b/services/java/com/android/server/input/InputManagerService.java
index bdd0aa4..a2e4ea0 100644
--- a/services/java/com/android/server/input/InputManagerService.java
+++ b/services/java/com/android/server/input/InputManagerService.java
@@ -20,6 +20,7 @@ import com.android.internal.R;
 import com.android.internal.util.XmlUtils;
 import com.android.server.Watchdog;
 
+import org.teameos.jellybean.settings.EOSConstants;
 import org.xmlpull.v1.XmlPullParser;
 
 import android.Manifest;
@@ -135,6 +136,8 @@ public class InputManagerService extends IInputManager.Stub implements Watchdog.
             new HashMap<IBinder, VibratorToken>();
     private int mNextVibratorTokenValue;
 
+    private boolean mHasTouchpad = false;
+
     // State for the currently installed input filter.
     final Object mInputFilterLock = new Object();
     InputFilter mInputFilter; // guarded by mInputFilterLock
@@ -179,6 +182,8 @@ public class InputManagerService extends IInputManager.Stub implements Watchdog.
     private static native void nativeReloadDeviceAliases(int ptr);
     private static native String nativeDump(int ptr);
     private static native void nativeMonitor(int ptr);
+    private static native void nativeSetTouchpadMode(int ptr, int mode);
+    private static native void nativeSetTouchpadStatus(int ptr, int status);
 
     // Input event injection constants defined in InputDispatcher.h.
     private static final int INPUT_EVENT_INJECTION_SUCCEEDED = 0;
@@ -226,14 +231,25 @@ public class InputManagerService extends IInputManager.Stub implements Watchdog.
         Slog.i(TAG, "Starting input manager");
         nativeStart(mPtr);
 
+        mHasTouchpad = mContext.getResources().getBoolean(
+                com.android.internal.R.bool.config_hasTouchpad);
+
         // Add ourself to the Watchdog monitors.
         Watchdog.getInstance().addMonitor(this);
 
         registerPointerSpeedSettingObserver();
         registerShowTouchesSettingObserver();
+        if (mHasTouchpad) {
+            registerTouchpadModeSettingObserver();
+            registerTouchpadStatusSettingObserver();
+        }
 
         updatePointerSpeedFromSettings();
         updateShowTouchesFromSettings();
+        if (mHasTouchpad) {
+            updateTouchpadModeFromSettings();
+            updateTouchpadStatusFromSettings();
+        }
     }
 
     public void systemReady(BluetoothService bluetoothService) {
@@ -1071,6 +1087,18 @@ public class InputManagerService extends IInputManager.Stub implements Watchdog.
         nativeSetShowTouches(mPtr, setting != 0);
     }
 
+    public void updateTouchpadModeFromSettings()
+    {
+        int mode = getTouchpadModeSetting(0);
+        nativeSetTouchpadMode(mPtr, mode);
+    }
+
+    public void updateTouchpadStatusFromSettings()
+    {
+        int status = getTouchpadStatusSetting(1);
+        nativeSetTouchpadStatus(mPtr, status);
+    }
+
     private void registerShowTouchesSettingObserver() {
         mContext.getContentResolver().registerContentObserver(
                 Settings.System.getUriFor(Settings.System.SHOW_TOUCHES), true,
@@ -1082,6 +1110,28 @@ public class InputManagerService extends IInputManager.Stub implements Watchdog.
                 });
     }
 
+    private void registerTouchpadModeSettingObserver() {
+        mContext.getContentResolver().registerContentObserver(
+                Settings.System.getUriFor(EOSConstants.DEVICE_SETTINGS_TOUCHPAD_MODE), true,
+                new ContentObserver(mHandler) {
+                    @Override
+                    public void onChange(boolean selfChange) {
+                        updateTouchpadModeFromSettings();
+                    }
+                });
+    }
+
+    private void registerTouchpadStatusSettingObserver() {
+        mContext.getContentResolver().registerContentObserver(
+                Settings.System.getUriFor(EOSConstants.DEVICE_SETTINGS_TOUCHPAD_STATUS), true,
+                new ContentObserver(mHandler) {
+                    @Override
+                    public void onChange(boolean selfChange) {
+                        updateTouchpadStatusFromSettings();
+                    }
+                });
+    }
+
     private int getShowTouchesSetting(int defaultValue) {
         int result = defaultValue;
         try {
@@ -1092,6 +1142,26 @@ public class InputManagerService extends IInputManager.Stub implements Watchdog.
         return result;
     }
 
+    private int getTouchpadModeSetting(int defaultValue) {
+        int result = defaultValue;
+        try {
+            result = Settings.System.getInt(mContext.getContentResolver(),
+                    EOSConstants.DEVICE_SETTINGS_TOUCHPAD_MODE);
+        } catch (SettingNotFoundException snfe) {
+        }
+        return result;
+    }
+
+    private int getTouchpadStatusSetting(int defaultValue) {
+        int result = defaultValue;
+        try {
+            result = Settings.System.getInt(mContext.getContentResolver(),
+                    EOSConstants.DEVICE_SETTINGS_TOUCHPAD_STATUS);
+        } catch (SettingNotFoundException snfe) {
+        }
+        return result;
+    }
+
     // Binder call
     @Override
     public void vibrate(int deviceId, long[] pattern, int repeat, IBinder token) {
diff --git a/services/java/com/android/server/pm/ShutdownThread.java b/services/java/com/android/server/pm/ShutdownThread.java
index 69406c8..e9b89bb 100644
--- a/services/java/com/android/server/pm/ShutdownThread.java
+++ b/services/java/com/android/server/pm/ShutdownThread.java
@@ -205,11 +205,15 @@ public final class ShutdownThread extends Thread {
             sIsStarted = true;
         }
 
+        final int shutdownMessageId = mRebootReason == null
+                ? com.android.internal.R.string.shutdown_progress
+                : com.android.internal.R.string.reboot_progress;
+
         // throw up an indeterminate system dialog to indicate radio is
         // shutting down.
         ProgressDialog pd = new ProgressDialog(context);
-        pd.setTitle(context.getText(com.android.internal.R.string.power_off));
-        pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress));
+        //pd.setTitle(context.getText(com.android.internal.R.string.power_off));
+        pd.setMessage(context.getText(shutdownMessageId));
         pd.setIndeterminate(true);
         pd.setCancelable(false);
         pd.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
diff --git a/services/java/com/android/server/wm/WindowManagerService.java b/services/java/com/android/server/wm/WindowManagerService.java
index 7011343..148af9f 100755
--- a/services/java/com/android/server/wm/WindowManagerService.java
+++ b/services/java/com/android/server/wm/WindowManagerService.java
@@ -5152,6 +5152,11 @@ public class WindowManagerService extends IWindowManager.Stub
         ShutdownThread.shutdown(mContext, true);
     }
 
+    @Override
+    public void reboot(String reason) {
+        ShutdownThread.reboot(mContext, reason, false);
+    }
+
     // Called by window manager policy.  Not exposed externally.
     @Override
     public void rebootSafeMode() {
diff --git a/services/jni/Android.mk b/services/jni/Android.mk
index e0a14af..7e7ee49 100644
--- a/services/jni/Android.mk
+++ b/services/jni/Android.mk
@@ -48,6 +48,10 @@ ifeq ($(WITH_MALLOC_LEAK_CHECK),true)
     LOCAL_CFLAGS += -DMALLOC_LEAK_CHECK
 endif
 
+ifeq ($(TARGET_HAS_DOCK_BATTERY),true)
+    LOCAL_CFLAGS += -DHAS_DOCK_BATTERY
+endif
+
 LOCAL_MODULE:= libandroid_servers
 
 include $(BUILD_SHARED_LIBRARY)
diff --git a/services/jni/com_android_server_BatteryService.cpp b/services/jni/com_android_server_BatteryService.cpp
index ca6f206..a96873f 100644
--- a/services/jni/com_android_server_BatteryService.cpp
+++ b/services/jni/com_android_server_BatteryService.cpp
@@ -49,6 +49,11 @@ struct FieldIds {
     jfieldID mBatteryVoltage;
     jfieldID mBatteryTemperature;
     jfieldID mBatteryTechnology;
+#ifdef HAS_DOCK_BATTERY
+    jfieldID mDockBatteryStatus;
+    jfieldID mDockBatteryLevel;
+    jfieldID mDockBatteryPresent;
+#endif
 };
 static FieldIds gFieldIds;
 
@@ -65,6 +70,11 @@ struct BatteryManagerConstants {
     jint healthOverVoltage;
     jint healthUnspecifiedFailure;
     jint healthCold;
+#ifdef HAS_DOCK_BATTERY
+    jint dockstatusCharging;
+    jint dockstatusNotCharging;
+    jint dockstatusUndocked;
+#endif
 };
 static BatteryManagerConstants gConstants;
 
@@ -78,6 +88,11 @@ struct PowerSupplyPaths {
     char* batteryVoltagePath;
     char* batteryTemperaturePath;
     char* batteryTechnologyPath;
+#ifdef HAS_DOCK_BATTERY
+    char* dockbatteryStatusPath;
+    char* dockbatteryCapacityPath;
+    char* dockbatteryPresentPath;
+#endif
 };
 static PowerSupplyPaths gPaths;
 
@@ -99,6 +114,21 @@ static jint getBatteryStatus(const char* status)
     }
 }
 
+#ifdef HAS_DOCK_BATTERY
+static jint getDockBatteryStatus(const char* status)
+{
+    switch (status[0]) {
+        case 'C': return gConstants.dockstatusCharging;         // Charging
+        case 'N': return gConstants.dockstatusNotCharging;      // Not charging
+
+        default: {
+            ALOGW("Unknown battery status '%s'", status);
+            return gConstants.dockstatusUndocked;
+        }
+    }
+}
+#endif
+
 static jint getBatteryHealth(const char* status)
 {
     switch (status[0]) {
@@ -199,6 +229,10 @@ static void android_server_BatteryService_update(JNIEnv* env, jobject obj)
     setBooleanField(env, obj, gPaths.acOnlinePath, gFieldIds.mAcOnline);
     setBooleanField(env, obj, gPaths.usbOnlinePath, gFieldIds.mUsbOnline);
     setBooleanField(env, obj, gPaths.batteryPresentPath, gFieldIds.mBatteryPresent);
+
+#ifdef HAS_DOCK_BATTERY
+    setIntField(env, obj, gPaths.dockbatteryCapacityPath, gFieldIds.mDockBatteryLevel);
+#endif
     
     setIntField(env, obj, gPaths.batteryCapacityPath, gFieldIds.mBatteryLevel);
     setVoltageField(env, obj, gPaths.batteryVoltagePath, gFieldIds.mBatteryVoltage);
@@ -212,6 +246,14 @@ static void android_server_BatteryService_update(JNIEnv* env, jobject obj)
     else
         env->SetIntField(obj, gFieldIds.mBatteryStatus,
                          gConstants.statusUnknown);
+
+#ifdef HAS_DOCK_BATTERY
+    if (readFromFile(gPaths.dockbatteryStatusPath, buf, SIZE) > 0)
+        env->SetIntField(obj, gFieldIds.mDockBatteryStatus, getDockBatteryStatus(buf));
+    else
+        env->SetIntField(obj, gFieldIds.mDockBatteryStatus,
+                         gConstants.dockstatusUndocked);
+#endif
     
     if (readFromFile(gPaths.batteryHealthPath, buf, SIZE) > 0)
         env->SetIntField(obj, gFieldIds.mBatteryHealth, getBatteryHealth(buf));
@@ -298,6 +340,19 @@ int register_android_server_BatteryService(JNIEnv* env)
                     if (access(path, R_OK) == 0)
                         gPaths.batteryTechnologyPath = strdup(path);
                 }
+#ifdef HAS_DOCK_BATTERY
+                else if(strcmp(buf, "DockBattery") == 0) {
+                    snprintf(path, sizeof(path), "%s/%s/status", POWER_SUPPLY_PATH, name);
+                    if (access(path, R_OK) == 0)
+                        gPaths.dockbatteryStatusPath = strdup(path);
+                    snprintf(path, sizeof(path), "%s/%s/capacity", POWER_SUPPLY_PATH, name);
+                    if (access(path, R_OK) == 0)
+                        gPaths.dockbatteryCapacityPath = strdup(path);
+                    snprintf(path, sizeof(path), "%s/%s/device/ec_dock", POWER_SUPPLY_PATH, name);
+                    if (access(path, R_OK) == 0)
+                        gPaths.dockbatteryPresentPath = strdup(path);
+                }
+#endif
             }
         }
         closedir(dir);
@@ -339,6 +394,12 @@ int register_android_server_BatteryService(JNIEnv* env)
     gFieldIds.mBatteryVoltage = env->GetFieldID(clazz, "mBatteryVoltage", "I");
     gFieldIds.mBatteryTemperature = env->GetFieldID(clazz, "mBatteryTemperature", "I");
 
+#ifdef HAS_DOCK_BATTERY
+    gFieldIds.mDockBatteryStatus = env->GetFieldID(clazz, "mDockBatteryStatus", "I");
+    gFieldIds.mDockBatteryLevel = env->GetFieldID(clazz, "mDockBatteryLevel", "I");
+    gFieldIds.mDockBatteryPresent = env->GetFieldID(clazz, "mDockBatteryPresent", "Ljava/lang/String;");
+#endif
+
     LOG_FATAL_IF(gFieldIds.mAcOnline == NULL, "Unable to find BatteryService.AC_ONLINE_PATH");
     LOG_FATAL_IF(gFieldIds.mUsbOnline == NULL, "Unable to find BatteryService.USB_ONLINE_PATH");
     LOG_FATAL_IF(gFieldIds.mBatteryStatus == NULL, "Unable to find BatteryService.BATTERY_STATUS_PATH");
@@ -392,6 +453,17 @@ int register_android_server_BatteryService(JNIEnv* env)
     gConstants.healthCold = env->GetStaticIntField(clazz,
             env->GetStaticFieldID(clazz, "BATTERY_HEALTH_COLD", "I"));
 
+#ifdef HAS_DOCK_BATTERY
+    gConstants.dockstatusCharging = env->GetStaticIntField(clazz,
+            env->GetStaticFieldID(clazz, "DOCK_STATE_CHARGING", "I"));
+
+    gConstants.dockstatusNotCharging = env->GetStaticIntField(clazz,
+            env->GetStaticFieldID(clazz, "DOCK_STATE_DISCHARGING", "I"));
+
+    gConstants.dockstatusUndocked = env->GetStaticIntField(clazz,
+            env->GetStaticFieldID(clazz, "DOCK_STATE_UNDOCKED", "I"));
+#endif
+
     return jniRegisterNativeMethods(env, "com/android/server/BatteryService", sMethods, NELEM(sMethods));
 }
 
diff --git a/services/jni/com_android_server_input_InputManagerService.cpp b/services/jni/com_android_server_input_InputManagerService.cpp
index 0e1ce51..9894ce6 100644
--- a/services/jni/com_android_server_input_InputManagerService.cpp
+++ b/services/jni/com_android_server_input_InputManagerService.cpp
@@ -178,6 +178,8 @@ public:
     void setSystemUiVisibility(int32_t visibility);
     void setPointerSpeed(int32_t speed);
     void setShowTouches(bool enabled);
+    void setTouchpadMode(int32_t mode);
+    void setTouchpadStatus(int32_t status);
 
     /* --- InputReaderPolicyInterface implementation --- */
 
@@ -240,6 +242,12 @@ private:
         // Show touches feature enable/disable.
         bool showTouches;
 
+        // The touchpad gesture mode.
+        int32_t touchpadMode;
+
+        // Touchpad status.
+        int32_t touchpadStatus;
+
         // Sprite controller singleton, created on first use.
         sp<SpriteController> spriteController;
 
@@ -285,6 +293,8 @@ NativeInputManager::NativeInputManager(jobject contextObj,
         mLocked.pointerSpeed = 0;
         mLocked.pointerGesturesEnabled = true;
         mLocked.showTouches = false;
+        mLocked.touchpadMode = 0;
+        mLocked.touchpadStatus = 1;
     }
 
     sp<EventHub> eventHub = new EventHub();
@@ -448,6 +458,10 @@ void NativeInputManager::getReaderConfiguration(InputReaderConfiguration* outCon
 
         outConfig->showTouches = mLocked.showTouches;
 
+        outConfig->touchpadMode = mLocked.touchpadMode;
+
+        outConfig->touchpadStatus = mLocked.touchpadStatus;
+
         outConfig->setDisplayInfo(0, false /*external*/,
                 mLocked.displayWidth, mLocked.displayHeight, mLocked.displayOrientation);
         outConfig->setDisplayInfo(0, true /*external*/,
@@ -775,6 +789,38 @@ void NativeInputManager::setShowTouches(bool enabled) {
             InputReaderConfiguration::CHANGE_SHOW_TOUCHES);
 }
 
+void NativeInputManager::setTouchpadMode(int32_t mode) {
+    { // acquire lock
+        AutoMutex _l(mLock);
+
+        if (mLocked.touchpadMode == mode) {
+            return;
+        }
+
+        ALOGI("Setting touchpad mode to %d.", mode);
+        mLocked.touchpadMode = mode;
+    } // release lock
+
+    mInputManager->getReader()->requestRefreshConfiguration(
+            InputReaderConfiguration::CHANGE_TOUCHPAD_MODE);
+}
+
+void NativeInputManager::setTouchpadStatus(int32_t status) {
+    { // acquire lock
+        AutoMutex _l(mLock);
+
+        if (mLocked.touchpadStatus == status) {
+            return;
+        }
+
+        ALOGI("Setting touchpad status to %d.", status);
+        mLocked.touchpadStatus = status;
+    } // release lock
+
+    mInputManager->getReader()->requestRefreshConfiguration(
+            InputReaderConfiguration::CHANGE_TOUCHPAD_STATUS);
+}
+
 bool NativeInputManager::isScreenOn() {
     return android_server_PowerManagerService_isScreenOn();
 }
@@ -1324,6 +1370,20 @@ static void nativeMonitor(JNIEnv* env, jclass clazz, jint ptr) {
     im->getInputManager()->getDispatcher()->monitor();
 }
 
+static void nativeSetTouchpadMode(JNIEnv* env,
+        jclass clazz, jint ptr, jint mode) {
+    NativeInputManager* im = reinterpret_cast<NativeInputManager*>(ptr);
+
+    im->setTouchpadMode(mode);
+}
+
+static void android_server_InputManager_nativeSetTouchpadStatus(JNIEnv* env,
+        jclass clazz, jint ptr, jint status) {
+    NativeInputManager* im = reinterpret_cast<NativeInputManager*>(ptr);
+
+    im->setTouchpadStatus(status);
+}
+
 // ----------------------------------------------------------------------------
 
 static JNINativeMethod gInputManagerMethods[] = {
@@ -1380,6 +1440,10 @@ static JNINativeMethod gInputManagerMethods[] = {
             (void*) nativeDump },
     { "nativeMonitor", "(I)V",
             (void*) nativeMonitor },
+    { "nativeSetTouchpadMode", "(II)V",
+            (void*) nativeSetTouchpadMode },
+    { "nativeSetTouchpadStatus", "(II)V",
+            (void*) android_server_InputManager_nativeSetTouchpadStatus },
 };
 
 #define FIND_CLASS(var, className) \
